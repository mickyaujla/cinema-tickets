# cinema-tickets

DWP Cinema Tickets take-home test in JavaScript.

The goal of the test was to implement a `TicketService` that enforces business rules and calls external methods for making payments and reserving seats.

## Getting started

1. `npm install` - install dependencies
2. `npm test` - run tests (more about testing [here](#testing))

## Project Structure
```
cinema-tickets/
├── package.json
├── jest.config.js
├── README.md
├── src/
│   ├── pairtest/
│   │   ├── TicketService.js    <- Core service logic
│   │   ├── lib/
│   │   │   ├── TicketTypeRequest.js
│   │   │   └── InvalidPurchaseException.js
│   │   └── constants/
│   │       └── index.js
│   └── thirdparty/
│       ├── paymentgateway/
│       │   └── TicketPaymentService.js
│       └── seatbooking/
│           └── SeatReservationService.js
├── test/
│   └── TicketService.test.js    <- Jest test suite
└── coverage/    <- generated by Jest after tests run
  ```

## Business Rules Implemented

- Maximum of **25 tickets** per purchase.  
- At least **1 adult ticket** required.  
- **Children and infants cannot be purchased without an adult.**  
- **Infants** do not require seats and must be <= number of adults.  
- Ticket prices:  
  - Adult => £25  
  - Child => £15  
  - Infant => £0

## Testing

Jest is used for unit testing where coverage is set to 100% specifically for [TicketService.js](src/pairtest/TicketService.js), the core coding aspect of this take-home test.

[TicketService.test.js](test/TicketService.test.js) is the test file for the `TicketService`.

The configuration for jest can be found in [jest.config.js](jest.config.js).

Once the tests have run the command: `open coverage/index.html` will open a coverage report in a browser.

Here are some additional unit tests that could be worthwhile adding in a real-world project:

- Valid purchase of exactly 25 tickets
- More thorough testing around costing and different variations of tickets
- Multiple requests of the same type i.e. 2 `TicketTypeRequest(TicketType.ADULT, 5)` requests should still add up correctly
- Verify Infant tickets do not increase seat count

## Future considerations

Since this was a take-home test, the focus was on meeting the brief requirements clearly and concisely. In a real-world project, however, there are several areas where this solution could be extended and improved. Below are some ideas for future enhancements:

### Add TypeScript
Introduce TypeScript to enforce types at compile time (e.g. `accountId`, `TicketTypeRequest`), reduce reliance on runtime validation, and improve maintainability.

### Refactoring Private Methods into Utility Functions

For the purpose of this exercise, I kept validation and summarisation logic as private methods within `TicketService` to match the challenge. In a real-world project, I’d consider extracting these into standalone utility functions to improve testability, keep classes single-purpose, and make business logic reusable across services. However, I weighed this against the task's scope and decided not to over-engineer.

### Dependency Injection
Instead of directly instantiating `TicketPaymentService` and `SeatReservationService`, inject them into `TicketService`. This would improve testability and make the design more flexible.

### Error Handling for External Services
In a production environment, I would wrap calls to external services such as `TicketPaymentService` and `SeatReservationService` in `try...catch` blocks to ensure that unexpected failures (e.g. network issues, provider downtime) can be gracefully handled.  

This might include:
- Retrying failed requests (with exponential backoff)
- Logging errors for monitoring/alerting
- Returning user-friendly error messages rather than allowing exceptions to bubble up

For the purposes of this take-home test, I omitted this to keep the implementation concise and because it was safe to assume the external providers behave reliably with no defects.

### More Granular Testing
- Add integration tests covering interactions between services.  
- Expand edge case coverage with additional unit tests (e.g. maximum ticket combinations, mixed request scenarios) as described above.

###  API Integration
Wrap `TicketService` in an API layer (REST or GraphQL) to expose it to a front-end application.

### CI/CD and Coverage
Integrate CI/CD pipelines with coverage thresholds to ensure business rules remain enforced as the code evolves.

### Reporting/Observability
Add logging and reporting on ticket sales, rejected purchases, and seat availability.